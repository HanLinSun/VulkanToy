#version 460 core
#include "random.glsl"
#include "intersections.glsl"
#include "sample.glsl"

#define MAX_STACK_DEPTH 64

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D targetTexture;

layout(binding = 1) uniform UniformBufferObject{
    RayTraceUniformBuffer ubo;
};

layout(binding = 2) readonly buffer PrimitiveBufferObject
{
    Primitive[] primitives;
};

layout(binding = 3) readonly buffer PBRMaterialBufferObject
{
    PBRMaterial[] Materials;
};

layout(binding = 4) uniform sampler2D[] materialTextures;

layout(binding = 5) readonly buffer LightBufferObject
{
    Light[] lights;
};

layout(std430, binding = 6) readonly buffer BVHBufferObject {
   LBVHNode[] bvhNodes;
 };

vec3 RayAt(Ray r, double t)
{
    return r.origin + r.direction * float(t);
}

bool HitScene(Ray r, inout Intersection intersection)
{
  bool hit =false;
  float tMin=MINIMUM;
  float tMax =INFINITY;
  Intersection temp_insec;
  float closest =tMax;
  for(int i=0;i<ubo.numPrimitives;i++)
  {  
      if(HitPrimitive(primitives[i],tMin,closest ,r,temp_insec))
      {
          hit=true;
          intersection =temp_insec;
          closest =temp_insec.t;
      }
  }
  return hit;
}

bool HitBVHNode(Ray r , inout Intersection intersection)
{
    float tMin =MINIMUM;
    float tMax =INFINITY;

    bool hit=false;
    float closest =tMax;

    int nodeStack[MAX_STACK_DEPTH];
    int toVisitOffset = 0;
    int currentNodeIndex = 0;
    vec3 invDir =vec3(1.0f / r.direction.x, 1.0f / r.direction.y, 1.f / r.direction.z);
    bool dirIsNeg[3] = {invDir.x < 0, invDir.y < 0, invDir.z < 0};
    //use stack to traverse BVH node
    while(true)
    {
       LBVHNode node = bvhNodes[currentNodeIndex];
       if(HitBoundingBox(r, node.pMin, node.pMax))
       {
             if(node.primitiveIdx !=-1)
             {
                 Intersection temp_insec;
                 if(HitPrimitive(primitives[node.primitiveIdx],tMin, closest,r,temp_insec))
                 {
                     hit =true;
                     intersection =temp_insec;
                     closest =temp_insec.t;
                 }
                 if (toVisitOffset == 0) break;
                 currentNodeIndex = nodeStack[--toVisitOffset];
             }
             else
             {
                if (dirIsNeg[node.splitAxis]==true) {
                    /// second child first
                    nodeStack[toVisitOffset++] = currentNodeIndex + 1;
                    currentNodeIndex = node.secondChildOffset;
                } else {
                    nodeStack[toVisitOffset++] = node.secondChildOffset;
                    currentNodeIndex = currentNodeIndex + 1;
                }
             }
       }
       else
       {
            if (toVisitOffset == 0) break;
            currentNodeIndex = nodeStack[--toVisitOffset];
       }
    }
    return hit;
}

vec3 DirectLight()

vec3 TraceRay(Ray r)
{
    Intersection intersection;
    vec3 radiance = vec3(1.0);
    vec3 throughout =vec3(1.0);

    LightSample lightSample;
    BSDFSample bsdfSample;

    Ray currentRay = r;

    for (int i = 0; i < ubo.maxDepth; i++)
    {
//       if (HitScene(currentRay, intersection))
       if(HitBVHNode(currentRay,intersection))
        {
            vec3 direction = intersection.normal + RandomInUnitSphere();
            currentRay.origin = intersection.position;
            currentRay.direction = normalize(direction);
            radiance *= 0.5;
        }
        else
        {
            vec3 unitDirection = normalize(currentRay.direction);
            float a = 0.5 * (unitDirection.y + 1.0);
            radiance *= (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
            break; // Exit the loop since there's no further intersection
        }
    }

     return radiance;
}

vec3 GammaCorrect(vec3 color)
{
     float gammaVal =1/2.2;
     float r = pow(color.r, gammaVal);
     float g = pow(color.g,gammaVal);
     float b = pow(color.b,gammaVal);
     return vec3(r,g,b);
}

void main()
{
   mat4 projInv =inverse(ubo.projMatrix);
   mat4 viewInv =inverse(ubo.viewMatrix);

    vec2 image_size = vec2(imageSize(targetTexture));

    uint SPP = ubo.spp; //sample per pixel
    vec3 radiance =vec3(0.0);

    for(int i=0;i<SPP;i++)
    {
       //size varient from pixel size[x: 0-1 y: 0-1]
        vec2 jitter = vec2(Random(),Random())/ image_size;

        float r1 =Random();
        float r2 =Random();

		vec3 lensOffset = vec3(0.01f/ 2.0 * SampleUniformDiskConcentric(r1,r2), 0.0);
        vec2 pixel     = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) + jitter;
       	vec2 uv        = vec2((pixel.x / image_size.x) * 2.0 - 1.0, (1.0 - pixel.y / image_size.y) * 2.0 - 1.0);
        vec4 origin    = viewInv * vec4(lensOffset, 1.0);
		vec4 target    = projInv * vec4(uv.x, uv.y, 1.0, 1.0);
		vec4 direction = viewInv * vec4(normalize(target.xyz * 0.5 - lensOffset), 0.0);

        vec3 rayDirection = normalize(direction.xyz); 
        Ray r;
        r.origin =origin.xyz;
    	r.direction = normalize(rayDirection);

        radiance += TraceRay(r);
    }

    radiance /= float(SPP);
    radiance =GammaCorrect(radiance);

    imageStore(targetTexture, ivec2(gl_GlobalInvocationID.xy), vec4(radiance, 0.0));

}
