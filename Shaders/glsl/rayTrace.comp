#version 450 core
#include "random.glsl"
#include "intersections.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D targetTexture;

layout(binding = 1) uniform UniformBufferObject{
    RayTraceUniformBuffer ubo;
};

layout(binding = 2) readonly buffer MeshBufferObject
{
    Mesh[] meshes;
};

layout(binding = 3) readonly buffer TriangleBufferObject
{
    Triangle[] triangles;
};

layout(binding = 4) readonly buffer PBRMaterialBufferObject
{
    PBRMaterial[] PBRaterials;
};

layout(binding = 5) readonly buffer SpheresBufferObject {
    Sphere[] spheres;
};

layout(binding = 6) uniform sampler2D[] materialTextures;


layout(binding = 7) readonly buffer LightBufferObject
{
    Light[] lights;
};

layout(std430, binding = 8) readonly buffer BVHBufferObject {
    BVHNode[] bvhNodes;
 };

vec3 RayAt(Ray r, double t)
{
    return r.origin + r.direction * float(t);
}

//Based on PBRT - BVH intersect
// bool HitBVHNode(Ray r , inout Intersection intersection)
// {
//     float tMin = 0.001;
//     float tMax = 10000;
//     int toVisitOffset = 0;
//     int currentNodeIndex = 0;
//     int nodesToVisit[64];
// 
//     float closest_intersection = tMax;
//     nodesToVisit[toVisitOffset++] =0;
// 
//     vec3 invDir=vec3(1 / r.direction.x, 1 / r.direction.y, 1 / r.direction.z);
//     bool dirIsNeg[3] = { invDir.x < 0, invDir.y < 0, invDir.z < 0 };
// 
//     bool hitAnything =false;
//     while(toVisitOffset>0)
//     {
//        currentNodeIndex= nodesToVisit[--toVisitOffset];
// 
//        BVHNode node = bvhNodes[currentNodeIndex];
//        if(node.isLeaf !=1)
//        {
//           bool intersectBoundBox = HitBoundingBox(r, node.min, node.max);
//           if(!intersectBoundBox) continue;
// 
//             // Advance to the near node first
//             if (dirIsNeg[bvhNodes[currentNodeIndex].axis]) {
//                 nodesToVisit[toVisitOffset++] = node.leftNodeIndex;
//                 nodesToVisit[toVisitOffset++] = node.rightNodeIndex;
//             }
//             else {
//                 nodesToVisit[toVisitOffset++] = node.rightNodeIndex;
//                 nodesToVisit[toVisitOffset++] = node.leftNodeIndex;
//             }
//        }
//        else
//        {
//             if (node.triangleIndex ==-1 && node.sphereIndex==-1) continue;
//             if(node.triangleIndex !=-1)
//             {
//                 Intersection temp_insec;
//                 if(HitTriangle(node.triangleIndex, r, tMin, closest_intersection ,temp_insec))
//                 {
//                   hitAnything =true;
//                   closest_intersection=temp_insec.t;
//                   intersection =temp_insec;
//                 }
//             }
//             if(node.sphereIndex!=-1)
//             {
//                 Intersection temp_insec;
//                 if(HitSphere(node.triangleIndex, r, tMin, closest_intersection,temp_insec))
//                 {
//                    hitAnything =true;
//                    closest_intersection=temp_insec.t;
//                   intersection =temp_insec;
//                 }
//             }
//        }
//     }
//     return hitAnything;
// }


float sphereIntersection(Mesh mesh, Ray r, inout Intersection intersection, bool outside) {

    Sphere sphere = spheres[mesh.sphereIdx];
    //Transform to local space
    vec3 ray_origin = multiplyMV(mesh.inverseTransform, vec4(r.origin, 1.0f));
    vec3 ray_direction = normalize(multiplyMV(mesh.inverseTransform,vec4(r.direction, 0.0f)));

    Ray rt;
    rt.origin = ray_origin;
    rt.direction = ray_direction;

    float vDotDirection = dot(rt.origin, rt.direction);
    float radicand = vDotDirection * vDotDirection - (dot(rt.origin, rt.origin) - pow(sphere.s.w, 2));

    if (radicand < 0) {
        return -1;
    }

    float squareRoot = sqrt(radicand);
    float firstTerm = -vDotDirection;
    float t1 = firstTerm + squareRoot;
    float t2 = firstTerm - squareRoot;

    float t = 0;
    if (t1 < 0 && t2 < 0) {
        return -1;
    } else if (t1 > 0 && t2 > 0) {
        t = min(t1, t2);
        outside = true;
    } else {
        t = max(t1, t2);
        outside = false;
    }

    vec3 objspaceIntersection = RayAt(rt, t);

    intersection.position = multiplyMV(mesh.transformMatrix, vec4(objspaceIntersection, 1.f));
    intersection.normal = normalize(multiplyMV(mesh.inverseTranspose, vec4(objspaceIntersection, 0.f)));
    if (!outside) {
         intersection.normal = -intersection.normal;
    }

    return length(r.origin -  intersection.position);
}


float meshIntersection(Mesh mesh, Ray r, inout Intersection intersection, inout bool outside)
{
    vec3 ray_origin = multiplyMV(mesh.inverseTransform,vec4(r.origin, 1.0f));
    vec3 ray_direction = normalize(multiplyMV(mesh.inverseTransform, vec4(r.direction, 0.0f)));
    Ray rt;
    rt.origin = ray_origin;
    rt.direction =  ray_direction;
    vec3 normal;
    float closestDist = INFINITY;

    Intersection temp_intersect;
    bool currOutside;

     uint closestTriangle_Idx = -1;
     uint triangleStartIdx = mesh.triangleStartIdx;

    for (uint i = mesh.triangleStartIdx; i < mesh.triangleStartIdx + mesh.triangleNums; i++)
    {
        float t = TriangleIntersectionTest(triangles[i], rt, temp_intersect);
        if (t == -1.f) continue;
        
        if (t < closestDist)
        {
            closestDist = t;
            intersection = temp_intersect;
            
            closestTriangle_Idx = triangleStartIdx + i;
        }
    }

    if (closestDist != INFINITY)
    {
        // calculate local space normal of the closest triangle
        float S = 0.5f * length(cross(triangles[closestTriangle_Idx].v0 -triangles[closestTriangle_Idx].v1, triangles[closestTriangle_Idx].v0 - triangles[closestTriangle_Idx].v2));
        float s1 = 0.5f * length(cross(intersection.position - triangles[closestTriangle_Idx].v1, intersection.position - triangles[closestTriangle_Idx].v2)) / S;
        float s2 = 0.5f * length(cross(intersection.position - triangles[closestTriangle_Idx].v2, intersection.position - triangles[closestTriangle_Idx].v0)) / S;
        float s3 = 0.5f * length(cross(intersection.position- triangles[closestTriangle_Idx].v0, intersection.position - triangles[closestTriangle_Idx].v1)) / S;
        normal = triangles[closestTriangle_Idx].n0 * s1 +  triangles[closestTriangle_Idx].n1 * s2 +  triangles[closestTriangle_Idx].n2 * s3;

        if (dot(rt.direction, normal) <= 0.f)
        {
            outside = true;
        }
        else
        {
            outside = false;
            normal = -normal;
        }

        // Turn intersection point and normal into world space
        intersection.position= multiplyMV(mesh.transformMatrix, vec4(  intersection.position, 1.f));
        intersection.normal = normalize(multiplyMV(mesh.inverseTranspose, vec4(normal, 0.f)));

        closestDist =length(r.origin - intersection.position);
        return closestDist;
    }
    return -1.f;
}

bool HitScene(Ray r, inout Intersection intersection) 
{
		float t;
		float t_min = INFINITY;
		int hit_mesh_index = -1;
		bool outside = true;

        Intersection temp_insec;

        for(int i=0;i<ubo.numMeshes;i++)
        {
            if(meshes[i].meshType ==0)
            {
                t=meshIntersection(meshes[i], r,  temp_insec, outside);
            }
//           else if(meshes[i].meshType ==1)
//           {
//              t=sphereIntersection(meshes[i], r,  temp_insec, outside);
//           }

            //Find nearest intersection point
            if(t>0.0f  && t_min >t )
            {
                t_min = t;
                hit_mesh_index = i;
            }
        }


        if (hit_mesh_index == -1)
		{
			return false;
		}
		else
		{
			//The ray hits something
            intersection =temp_insec;
			intersection.t = t_min;
			intersection.materialID = meshes[hit_mesh_index].material_ID;
		}
        return true;
}

vec3 TraceRay(Ray r)
{
    Intersection intersection;
    vec3 radiance = vec3(1.0);
    Ray currentRay = r;

    for (int i = 0; i < ubo.maxDepth; i++)
    {
       if (HitScene(currentRay, intersection))
        {
            vec3 direction = intersection.normal + RandomInUnitSphere();
            currentRay.origin = intersection.position;
            currentRay.direction = normalize(direction);
            radiance *= 0.5;
        }
        else
        {
            vec3 unitDirection = normalize(currentRay.direction);
            float a = 0.5 * (unitDirection.y + 1.0);
            radiance *= (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
            break; // Exit the loop since there's no further intersection
        }
    }
     return radiance;
}

vec3 GammaCorrect(vec3 color)
{
     float gammaVal =1/2.2;
     float r = pow(color.r, gammaVal);
     float g = pow(color.g,gammaVal);
     float b = pow(color.b,gammaVal);
     return vec3(r,g,b);
}

void main()
{
    vec2 image_size = vec2(imageSize(targetTexture));
    float y_scaled = ubo.cameraFOV * PI / 180.f;

    float x_scaled = (y_scaled * image_size.x) / image_size.y;
    float fovx = (atan(x_scaled) * 180) / PI;
    float fovy = ubo.cameraFOV;

    vec2 cameraFOV = vec2(fovx, fovy);

    vec2 pixelLength = vec2(2.0f * x_scaled/image_size.x, 2.0f *y_scaled/image_size.y);


    //This is world space, when do intersection test need to transform to local space
    vec3 radiance = vec3(0.0);
    vec3 cameraviewDir = normalize(ubo.cameraLookAt - ubo.cameraPos);
    vec3 cameraRight = normalize(cross(cameraviewDir, ubo.camera_Up));

    uint SPP = ubo.spp; //sample per pixel

    for(int i=0;i<SPP;i++)
    {
       //size varient from pixel size[x: 0-1 y: 0-1]
        vec2 jitter = vec2(Random(),Random())/ image_size;
        float x_offset = float(gl_GlobalInvocationID.x+jitter.x) - float(image_size.x * 0.5f);
        float y_offset = float(gl_GlobalInvocationID.y+jitter.y) - float(image_size.y * 0.5f);

        vec3 deltaX =  cameraRight * pixelLength.x * x_offset;
        vec3 deltaY =  ubo.camera_Up * pixelLength.y * y_offset;

        vec3 rayDirection = normalize(cameraviewDir - deltaX -deltaY); 
        Ray r;
        r.origin = ubo.cameraPos;
    	r.direction = normalize(rayDirection);

        radiance += TraceRay(r);
    }

    radiance /= float(SPP);
    radiance =GammaCorrect(radiance);

    imageStore(targetTexture, ivec2(gl_GlobalInvocationID.xy), vec4(radiance, 0.0));

}
