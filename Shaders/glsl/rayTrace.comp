#version 460 core
#include "random.glsl"
#include "intersections.glsl"
#include "sample.glsl"

#define MAX_STACK_DEPTH 24

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(binding = 0, rgba8) uniform writeonly image2D targetTexture;

layout(binding = 1) uniform UniformBufferObject{
    RayTraceUniformBuffer ubo;
};

layout(binding = 2) readonly buffer PrimitiveBufferObject
{
    Primitive[] primitives;
};

layout(binding = 3) readonly buffer PBRMaterialBufferObject
{
    PBRMaterial[] Materials;
};

layout(binding = 4) uniform sampler2D[] materialTextures;

layout(binding = 5) readonly buffer LightBufferObject
{
    Light[] lights;
};

layout(std430, binding = 6) readonly buffer BVHBufferObject {
   LBVHNode[] bvhNodes;
 };


vec3 RayAt(Ray r, double t)
{
    return r.origin + r.direction * float(t);
}


bool HitTriangle(Primitive prim, Ray r,float tMin, float tMax,  inout Intersection intersection)
{
    vec3 ray_origin = multiplyMV(prim.inverseTransform, vec4(r.origin,1.0f));
    vec3 ray_direction = multiplyMV(prim.inverseTransform, vec4(r.direction ,0.0f));

    Triangle t = prim.triangle;
    vec3 n = vec3(0, 0, 0);
    vec3 hit = TriangleIntersection(ray_origin, ray_direction, t, n);
    if (!(hit.y < 0.0 || hit.y>1.0 || hit.z < 0.0 || (hit.y + hit.z)>1.0))
    {
        intersection.position = ray_origin + hit.x * ray_direction;
        intersection.normal = normalize(n);
        intersection.backFaceFlag = dot(ray_direction, intersection.normal) > 0 ? 1 : 0;
        intersection.normal *= 1 - 2 * intersection.backFaceFlag;
        intersection.position += intersection.normal * 0.0001;

        //back to world space
        intersection.position =multiplyMV( prim.transform , vec4( intersection.position,1.0));
        intersection.normal =multiplyMV( prim.inverseTranspose, vec4(intersection.normal,0.0));

        intersection.t = hit.x;
        intersection.material_ID = prim.materialIdx;
        return hit.x > tMin && hit.x < tMax;
    }
    return false;
}

bool HitBoundingBox(Ray r, vec3 boxMin, vec3 boxMax)
{
    // world space intersection test
    vec3 tMin = (boxMin - r.origin)/r.direction;
    vec3 tMax = (boxMax -r.origin)/r.direction;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    return (t2.x>=t1.x) &&(t2.y>=t1.y) &&(t2.z>=t1.z);
}

bool HitSphere(Primitive prim, Ray r, float tMin, float tMax, inout Intersection intersection)
{

    vec3 ray_origin = multiplyMV(prim.inverseTransform, vec4(r.origin,1.0f));
    vec3 ray_direction = multiplyMV(prim.inverseTransform, vec4(r.direction ,0.0f));

    vec3 center = prim.sphere.s.xyz;
    float radius = prim.sphere.s.w;
    vec3 oc = center - ray_origin;
    float a = dot(ray_direction, ray_direction);
    float half_b = dot(ray_direction, oc);
    float c = dot(oc, oc) - radius * radius;
    float discriminant = half_b * half_b - a * c;

    if (discriminant < 0)
    {
        return false;
    }
    float sqrt_d = sqrt(discriminant);

    // Find the nearest root that lies in the acceptable range.
    float root = (half_b - sqrt_d) / a;
    intersection.backFaceFlag = 0;
    if (root < tMin || tMax < root)
    {
        root = (half_b + sqrt_d) / a;
        intersection.backFaceFlag = 1;
        if (root <= tMin || tMax <= root)
            return false;
    }

    intersection.t = root;

    intersection.position =  ray_origin + intersection.t * ray_direction;
    intersection.normal = (1 - 2 * intersection.backFaceFlag) * ((intersection.position - center) / radius);
   
    //back to world space
    intersection.position =multiplyMV( prim.transform , vec4( intersection.position,1.0));
    intersection.normal =multiplyMV( prim.inverseTranspose, vec4(intersection.normal,0.0));
    return true;
}


bool HitPrimitive(Primitive prim, Ray r, inout Intersection intersection)
{
   float tMin =MINIMUM;
   float tMax=INFINITY;
   if(prim.type==0)
   {
     return HitTriangle(prim,r,tMin,tMax,intersection);
   }
   else if(prim.type==1)
   {
    return HitSphere(prim,r,tMin,tMax,intersection);
   }
}

bool HitBVHNode(Ray r , inout Intersection intersection)
{
    float tMin =MINIMUM;
    float tMax =INFINITY;

    bool hit=false;
    float closest =tMax;

    int nodeStack[MAX_STACK_DEPTH];
    int toVisitOffset = 0;
    int currentNodeIndex = 0;
    vec3 invDir =vec3(1.0f / r.direction.x, 1.0f / r.direction.y, 1.f / r.direction.z);
    bool dirIsNeg[3] = {invDir.x < 0, invDir.y < 0, invDir.z < 0};
    //use stack to traverse BVH node
    while(true)
    {
       LBVHNode node = bvhNodes[currentNodeIndex];
       if(HitBoundingBox(r, node.pMin, node.pMax))
       {
             if(node.primitiveIdx !=-1)
             {
                 Intersection temp_insec;
                 hit = HitPrimitive(primitives[node.primitiveIdx],r,temp_insec);
                 intersection =temp_insec;

                 if (toVisitOffset == 0) break;
                 currentNodeIndex = nodeStack[--toVisitOffset];
             }
             else
             {
                if (dirIsNeg[node.splitAxis]==true) {
                    /// second child first
                    nodeStack[toVisitOffset++] = currentNodeIndex + 1;
                    currentNodeIndex = node.secondChildOffset;
                } else {
                    nodeStack[toVisitOffset++] = node.secondChildOffset;
                    currentNodeIndex = currentNodeIndex + 1;
                }
             }
       }
       else
       {
            if (toVisitOffset == 0) break;
            currentNodeIndex = nodeStack[--toVisitOffset];
       }
    }
    return hit;
}


vec3 TraceRay(Ray r)
{
    Intersection intersection;
    vec3 radiance = vec3(1.0);
    vec3 throughout =vec3(1.0);

    LightSample lightSample;
    BSDFSample bsdfSample;

    Ray currentRay = r;

    for (int i = 0; i < ubo.maxDepth; i++)
    {
  //    if (HitScene(currentRay, intersection))
       if(HitBVHNode(currentRay,intersection))
        {
            vec3 direction = intersection.normal + RandomInUnitSphere();
            currentRay.origin = intersection.position;
            currentRay.direction = normalize(direction);
            radiance *= 0.5;
        }
        else
        {
            vec3 unitDirection = normalize(currentRay.direction);
            float a = 0.5 * (unitDirection.y + 1.0);
            radiance *= (1.0 - a) * vec3(1.0, 1.0, 1.0) + a * vec3(0.5, 0.7, 1.0);
            break; // Exit the loop since there's no further intersection
        }
    }

     return radiance;
}

vec3 GammaCorrect(vec3 color)
{
     float gammaVal =1/2.2;
     float r = pow(color.r, gammaVal);
     float g = pow(color.g,gammaVal);
     float b = pow(color.b,gammaVal);
     return vec3(r,g,b);
}

void main()
{
   mat4 projInv =inverse(ubo.projMatrix);
   mat4 viewInv =inverse(ubo.viewMatrix);

    vec2 image_size = vec2(imageSize(targetTexture));

    uint SPP = ubo.spp; //sample per pixel
    vec3 radiance =vec3(0.0);

    for(int i=0;i<SPP;i++)
    {
       //size varient from pixel size[x: 0-1 y: 0-1]
        vec2 jitter = vec2(Random(),Random())/ image_size;

        float r1 =Random();
        float r2 =Random();

		vec3 lensOffset = vec3(0.01f/ 2.0 * SampleUniformDiskConcentric(r1,r2), 0.0);
        vec2 pixel     = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) + jitter;
       	vec2 uv        = vec2((pixel.x / image_size.x) * 2.0 - 1.0, (1.0 - pixel.y / image_size.y) * 2.0 - 1.0);
        vec4 origin    = viewInv * vec4(lensOffset, 1.0);
		vec4 target    = projInv * vec4(uv.x, uv.y, 1.0, 1.0);
		vec4 direction = viewInv * vec4(normalize(target.xyz * 0.5 - lensOffset), 0.0);

        vec3 rayDirection = normalize(direction.xyz); 
        Ray r;
        r.origin =origin.xyz;
    	r.direction = normalize(rayDirection);

        radiance += TraceRay(r);
    }

    radiance /= float(SPP);
    radiance =GammaCorrect(radiance);

    imageStore(targetTexture, ivec2(gl_GlobalInvocationID.xy), vec4(radiance, 0.0));

}
